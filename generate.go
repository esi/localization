// generate errors.go -- batteries *NOT* included
//
// usage:
//   ./localization [-p <package>] | gofmt > /path/to/errors.go
//

package main

import (
	"fmt"
	"io/ioutil"
	"reflect"
	"regexp"
	"sort"
	"strings"
	"unicode/utf8"

	toml "github.com/pelletier/go-toml"
	kingpin "gopkg.in/alecthomas/kingpin.v2"
)

var (
	flagPackage = kingpin.Flag(
		"package",
		"specify the generated package name",
	).Short('p').Default("main").String()
)

// TranslatedError describes an error with a comment attribute
type TranslatedError struct {
	Comment string `toml:"comment"`
	De      string `toml:"de"`
	EnUS    string `toml:"en-us"`
	EsES    string `toml:"es-es"`
	Fr      string `toml:"fr"`
	Ja      string `toml:"ja"`
	Ru      string `toml:"ru"`
	Zh      string `toml:"zh"`
}

// Errors lists all errors defined in errors.toml
// XXX would be nice to delete this and use map[string]TranslatedError
type Errors struct {
	ErrorAuth         TranslatedError
	ErrorBanned       TranslatedError
	ErrorCreate       TranslatedError
	ErrorCreateSSO    TranslatedError
	ErrorDatasource   TranslatedError
	ErrorESIJSON      TranslatedError
	ErrorHeaderParse  TranslatedError
	ErrorLimited      TranslatedError
	ErrorMethod       TranslatedError
	ErrorNoAuth       TranslatedError
	ErrorNotFound     TranslatedError
	ErrorProxy        TranslatedError
	ErrorRead         TranslatedError
	ErrorReadResponse TranslatedError
	ErrorReadSSO      TranslatedError
	ErrorRequestSSO   TranslatedError
	ErrorSSOJSON      TranslatedError
	ErrorTimeout      TranslatedError
	ErrorTimeoutSSO   TranslatedError
	ErrorTokenID      TranslatedError
	ErrorTokenTime    TranslatedError
	ErrorWrite        TranslatedError
}

func main() {
	kingpin.CommandLine.HelpFlag.Short('h')
	kingpin.Parse()
	rawToml, err := ioutil.ReadFile("errors.toml")
	if err != nil {
		panic(fmt.Sprintf("failed to read errors.toml: %+v", err))
	}

	regex := regexp.MustCompile("# (?P<comment>.*)")
	withComments := regex.ReplaceAll(rawToml, []byte("comment = \"${comment}\""))

	e := Errors{}
	if tomlErr := toml.Unmarshal(withComments, &e); tomlErr != nil {
		panic(fmt.Sprintf("failed to unmarshal errors.toml: %+v", tomlErr))
	}

	buildErrorsGo(e)
}

func buildErrorsGo(e Errors) {
	val := reflect.Indirect(reflect.ValueOf(e))

	names := []string{}
	indexes := map[string]int{}
	for i := 0; i < val.NumField(); i++ {
		name := val.Type().Field(i).Name
		names = append(names, name)
		indexes[name] = i
	}

	fmt.Printf(
		"// ESI Translated Errors\n//\n"+
			"// Note: this file is autogenerated, you shouldn't edit it\n\n"+
			"package %s\n\n"+
			"var (\n",
		*flagPackage,
	)

	sort.Strings(names)
	for j, name := range names {
		translatedErr := val.Field(indexes[name]).Interface().(TranslatedError)
		tval := reflect.Indirect(reflect.ValueOf(translatedErr))

		if j > 0 {
			fmt.Println()
		}

		fmt.Printf(
			"\t// %s\n"+
				"\t%s = TranslatedError{map[string]string{\n",
			translatedErr.Comment,
			name,
		)

		for i := 0; i < tval.NumField(); i++ {
			lang := tval.Type().Field(i).Tag.Get("toml")
			if lang == "comment" {
				continue
			}

			value := tval.Field(i).Interface().(string)

			if utf8.RuneCountInString(value) <= 60 {
				fmt.Printf(
					"\t\t%q: %q,\n",
					lang,
					value,
				)
			} else {

				valSplit := strings.Split(value, " ")
				buffer := fmt.Sprintf("\t\t%q: \"%s", lang, valSplit[0])

				for _, word := range valSplit[1:] {
					if utf8.RuneCountInString(buffer)+utf8.RuneCountInString(word) > 60 {
						fmt.Printf("%s \" +\n", buffer)
						buffer = fmt.Sprintf("\t\t\t\"%s", word)
					} else {
						buffer += fmt.Sprintf(" %s", word)
					}
				}

				fmt.Printf("%s\",\n", buffer)
			}

		}
		fmt.Println("\t}}")
	}
	fmt.Println(")")
}
